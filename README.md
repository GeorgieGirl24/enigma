# Enigma and the Bombe

For this project we were asked to give a self evaluation of our project.


## Functionality: ##

- Enigma Class with encrypt and decrypt methods successfully implemented. Encrypt/decrypt command line interfaces successfully implemented
 * I believe that the two runners are successfully running... and bring back the correct information.  This was a challenge, but I think that I was able to deliver on the requirements. I would take a three and be very happy.

## Object Oriented Programming: ##

- Project is broken into logical components that are appropriately encapsulated. No classes are unreasonably small or large, or contain knowledge/information/behavior that they shouldnâ€™t know about. Student can articulate the single responsibilities of the various components.

  * I was able to make a plan and stick to it, for the most part. I was trying to have only one class that interacted with the terminal which worked out in some ways just like I wanted it to. I was able to keep the methods short and tried to pull out all of the helper methods that I could. I would take a three on this portion.

## Ruby Conventions and Mechanics: ## 

 - Code is mostly properly indented, spaced, and lines are not excessively long. Class, method, variable, and file names follow convention. Some enumerables/data structures chosen are the most efficient tool for a given job, and students can speak as to why those enumerables/data structures were chosen. At least one hash is implemented in a way that makes logical sense.
 
 * I was able to use more enumberables than I have in the past. I was able to find some really interesting and dynamic ones, for example #each_slice(1), #reduce, #send, #merge and #rotate. This is on par with a three.

## Test Driven Development: ##

- Every method is tested at both the unit and integration level, and completely verify expected behavior (i.e., if a single method does 3 things, all 3 things are explicitly tested). Obvious edge cases are addressed. git history demonstrates students are writing tests before implementation code. Test coverage metrics show coverage at 99% or greater.

  * I do currently have one line that isn't covered and I can't see to find it. But I am still over 99% in coverage for testing. I will say that this was a mastery of wills to make the mocking and stubbing of the test suites work.  I believe that I need more practice to make this part more efficient (from the point of view of my time). I would be happy with a three

## Version Control: ##

- At least 30 commits. Most pull requests include related and logical chunks of functionality, and are named and documented to clearly communicate the purpose of the pull request. No more than 3 commits include multiple pieces of functionality.

  * I will have well over 30 commits, but I struggled with naming my branches in the most effective ways. I could have probably broken my work of the set-up branch onto two different branches. I would say that this is a 2.5
